package com.service.aiintegration.service.impl;

import com.service.aiintegration.common.Constants;
import com.service.aiintegration.entity.Memory;
import com.service.aiintegration.repositary.MemoryRepository;
import com.service.aiintegration.service.AiService;
import com.service.aiintegration.service.RagService;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Collectors;

@Service
@AllArgsConstructor
/** * Service implementation for Retrieval-Augmented Generation (RAG) operations.
 */
public class RagServiceImpl implements RagService {
    private final Logger log = Logger.getLogger(RagServiceImpl.class.getName());
    private final MemoryRepository repository;
    private final AiService aiService;
    @Override
    @Transactional
    /** Method to save memory with embedding.
     * @param type The type of memory.
     * @param key The key for the memory.
     * @param value The value of the memory.
     * @return The saved Memory entity.
     */
    public Memory saveMemory(String type, String key, String value) {
        log.info("Saving memory with type: " + type + ", key: " + key + ", value: " + value);
        Double[] embedding = aiService.generateEmbedding(value);
        Memory memory = Memory.builder()
                .key(key)
                .type(type)
                .embedding(embedding)
                .value(value)
                .build();
        log.info("Saving memory with type: " + type + ", key: " + key + ", value: " + value);
        return repository.save(memory);
    }
    // Query using RAG
    @Override
    @Transactional
    /** Method to query memory using Retrieval-Augmented Generation (RAG).
     * @param userQuery The user's query.
     * @return The response generated by the AI service.
     */
    public String query(String userQuery) {
        log.info("Querying memory with type: " + userQuery);
        Double[] queryEmbedding = aiService.generateEmbedding(userQuery);
        if (queryEmbedding == null || queryEmbedding.length == Constants.ZERO) {
            log.info("Query embedding is empty or null; aborting RAG retrieval.");
            return aiService.ask(userQuery, List.of());
        }
        // Vector similarity search: skip memories without embeddings
        List<Memory> memories = repository.findAll().stream()
                .filter(m -> m.getEmbedding() != null && m.getEmbedding().length > 0)
                .collect(Collectors.toCollection(ArrayList::new));
        if (memories.isEmpty()) {
            log.info("No memories with embeddings found.");
            return aiService.ask(userQuery, List.of());
        }
        memories.sort(Comparator.comparingDouble(
                m -> -aiService.cosineSimilarity(queryEmbedding, m.getEmbedding())
        ));
        List<String> topContext = memories.stream()
                .limit(Constants.LIMIT)
                .map(Memory::getValue)
                .toList();
        log.info("Querying memory with type: " + userQuery);
        return aiService.ask(userQuery, topContext);
    }
}
